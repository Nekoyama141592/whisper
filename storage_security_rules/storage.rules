rules_version = '2';
service firebase.storage {

  function isTheSameUser(uid) {
    return request.auth.uid == uid;
  }

  function isNotTheSameThing(resource) {
    return resource == null;
  }

  function isValidPost(storagePostName) {
    return storagePostName.matches('.*\\.aac') && request.resource.contentType == 'video/mp4';
  }

  function isValidImage(imageName) {
    return imageName.matches('.*\\.jpeg') && request.resource.contentType == 'image/jpeg';
  }

  function canCreate(uid, resource) {
    return isTheSameUser(uid) && isNotTheSameThing(resource);
  }

  match /b/{bucket}/o {
    match /postImages/{uid} {
      allow read, write: if isTheSameUser(uid);
      match /{postId} {
       allow read, write: if isTheSameUser(uid);
        match /{storagePostImageName} {
         allow read, delete: if isTheSameUser(uid) && isValidImage(storagePostImageName) ;
         allow create: if canCreate(uid,resource) && isValidImage(storagePostImageName) ;
        }
      }
    }

    match /posts/{uid} {
     allow read, write: if isTheSameUser(uid);
      match /{postId} {
       allow read, write: if isTheSameUser(uid);
        match /{storagePostName} {
         allow read, delete: if isTheSameUser(uid) && isValidPost(storagePostName) ;
         allow create: if canCreate(uid,resource) && isValidPost(storagePostName) ;
        }
      }
    }

    match /userImages/{uid} {
     allow read, write: if isTheSameUser(uid);
      match /{storageImageName} {
       allow read, delete: if isTheSameUser(uid) && isValidImage(storageImageName) ;
       allow create: if canCreate(uid,resource) && isValidImage(storageImageName);
      }
    }

  }
}
